use rpg_game::entity::{CppEntity, Entity, EntityBuilder, PythonEntity, RustEntity};
use rpg_game::moves::Move;
use rpg_game::ui::{Button, ButtonLink, EntityStats};
use rpg_game::{ActionType, Team};

use macroquad::prelude::*;

use std::collections::HashMap;
use std::collections::VecDeque;

#[derive(PartialEq, Clone)]
enum State {
    Wait,
    Move,
    Dialogue(Box<State>),
    End,
    Switch,
}

struct Battle<'a> {
    player: Entity,
    player_team: Team,
    enemy: Entity,
    enemy_team: Team,
    state: State,
    debounce: bool,
    debounce_step: bool,
    text_queue: VecDeque<String>,
    player_ui: EntityStats<'a>,
    enemy_ui: EntityStats<'a>,
    attack_button: Button<'a>,
    switch_button: Button<'a>,
    empty_button_texture: Texture2D,
}

#[macroquad::main("RPG Game")]
async fn main() {
    // create player and enemy teams
    let mut player_team = Team::new();
    player_team.push(RustEntity::build(0));
    player_team.push(PythonEntity::build(0));

    let mut enemy_team = Team::new();
    let enemy_cpp = CppEntity::build(0);
    enemy_team.push(enemy_cpp);

    // get active player and enemy.
    let player = player_team
        .get_active()
        .expect("Active player has somehow been destroyed");

    let enemy = enemy_team
        .get_active()
        .expect("Active enemy has somehow been destroyed");

    // load textures
    let empty_button_texture: Texture2D = load_texture("assets/empty-button.png").await.unwrap();
    let attack_button_texture: Texture2D = load_texture("assets/attack-button.png").await.unwrap();
    let switch_button_texture: Texture2D = load_texture("assets/switch-button.png").await.unwrap();
    let health_bar_texture: Texture2D = load_texture("assets/health-bar.png").await.unwrap();

    // create ui elements
    let attack_button = Button::new(&attack_button_texture, 1100.0, 600.0);
    let switch_button = Button::new(&switch_button_texture, 1100.0, 650.0);
    let player_ui = EntityStats::new(100.0, 600.0, &health_bar_texture);
    let enemy_ui = EntityStats::new(600.0, 100.0, &health_bar_texture);

    // change the window to fullscreen
    set_fullscreen(true);

    // initialize state
    let state = State::Wait;

    let text_queue: VecDeque<String> = VecDeque::new();
    let debounce = false;
    let debounce_step = false;

    let mut battle = Battle {
        player,
        player_team,
        enemy,
        enemy_team,
        debounce,
        debounce_step,
        state,
        text_queue,
        player_ui,
        enemy_ui,
        attack_button,
        switch_button,
        empty_button_texture,
    };

    // game loop
    loop {
        // refresh frame
        clear_background(BLACK);

        battle.update();

        next_frame().await;
    }
}

impl Battle<'_> {
    pub fn update(&mut self) -> bool {
        // update player and enemy health.
        self.player_ui.update(
            self.player.health,
            self.player.max_health,
            format!("{}", self.player).as_str(),
        );
        self.enemy_ui.update(
            self.enemy.health,
            self.enemy.max_health,
            format!("{}", self.enemy).as_str(),
        );

        match self.state {
            State::Dialogue(ref transition_state) => {
                let state_clone = transition_state.clone();
                self.dialogue(state_clone);
            }

            State::Wait => {
                self.wait_state();
            }

            State::Move => {
                self.move_state();
            }
            State::Switch => {
                switch_state();
            }
            State::End => {
                return true;
            }
        }

        if self.debounce && self.debounce_step {
            self.debounce = false;
            self.debounce_step = false;
        } else if self.debounce {
            self.debounce_step = true
        }

        false
    }

    fn wait_state(&mut self) {
        // draw buttons.
        self.attack_button.draw();

        // do action.
        let mut battle_action = ActionType::Wait;
        if self.attack_button.clicked() && !self.debounce {
            self.state = State::Move;
            self.debounce = true;
        }

        if self.switch_button.clicked() {
            self.state = State::Switch;
        }

        if let ActionType::Switch = battle_action {
            //rpg_game::switch_player(&mut player_team);
        }

        if let ActionType::Forfeit = battle_action {
            self.text_queue.push_back(String::from(
                "You decided that the battle was futile and quit early",
            ));
            self.state = State::End;
        }
    }
    fn move_state(&mut self) {
        let mut player_mv: Option<Move> = None;
        let mut move_buttons: HashMap<Move, Button> = HashMap::new();

        // add buttons for all the moves
        for (i, mv) in self.player.get_moves().iter().enumerate() {
            move_buttons.insert(
                mv.clone(),
                Button::new(
                    &self.empty_button_texture,
                    1100.0,
                    600.0 + (75.0 * (i as f32)),
                ),
            );
        }

        // check if any of the buttons are clicked
        for (mv, mut button) in move_buttons.into_iter() {
            button.draw();
            if button.clicked() && !self.debounce {
                self.debounce = true;
                player_mv = Some(mv);
            }

            // draw text on top of the button
            draw_text(
                format!("{}", mv).as_str(),
                button.xpos + 10.0,
                button.ypos + 40.0,
                30.0,
                WHITE,
            );
        }

        if let Some(mv) = player_mv {
            self.player.queue_move(mv);
            rpg_game::queue_enemy_move(&mut self.enemy);
            rpg_game::execute_moves(&mut self.player, &mut self.enemy, &mut self.text_queue);
            self.state = State::Dialogue(Box::new(State::Wait));
        }

        if self.player.health == 0 {
            self.text_queue
                .push_back(format!("The player, {}, has fallen.", self.player));
            if active_died(&mut self.player_team, &mut self.state) {
                return;
            }
            self.player = self
                .player_team
                .get_active()
                .expect("Active player has somehow been destroyed");
        }
        if self.enemy.health == 0 {
            self.text_queue
                .push_back(format!("The enemy, {}, has fallen.", self.enemy));
            if active_died(&mut self.enemy_team, &mut self.state) {
                return;
            }
            self.enemy = self
                .enemy_team
                .get_active()
                .expect("Active enemy has somehow been destroyed");
        }
    }

    fn dialogue(&mut self, transition_state: Box<State>) {
        let s = match self.text_queue.get(0) {
            Some(s) => s,
            None => {
                self.state = *transition_state;
                return;
            }
        };
        draw_multiline_text(s, 50.0, 725.0, 40.0, Some(1.5), WHITE);

        if is_mouse_button_pressed(MouseButton::Left) {
            self.text_queue.pop_front();
        }
    }

    fn switch_state(&mut self) {
        let mut links: Vec<ButtonLink<Entity>> = Vec::new();
        for (i, e) in self.player_team.entities.iter() {
            links.append(ButtonLink {
                link: e,
                button: Button::new(
                    &self.empty_button_texture,
                    1100.0,
                    600.0 + (75.0 * (i as f32)),
                ),
            });
        }

        // check if any of the buttons are clicked
        for (mv, mut button) in move_buttons.into_iter() {
            button.draw();
            if button.clicked() && !self.debounce {
                self.debounce = true;
                player_mv = Some(mv);
            }

            // draw text on top of the button
            draw_text(
                format!("{}", mv).as_str(),
                button.xpos + 10.0,
                button.ypos + 40.0,
                30.0,
                WHITE,
            );
        }
    }
}

fn active_died(team: &mut Team, state: &mut State) -> bool {
    if let Err(_) = team.set_active(team.get_active_index() + 1) {
        *state = State::Dialogue(Box::new(State::End));
        return true;
    };
    false
}
